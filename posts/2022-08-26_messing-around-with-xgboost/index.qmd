---
title: "Messing around with XGBoost" # <---- UPDATE ME
description:
  I've been reading about XGBoost and wanted to take it for a ride # <---- UPDATE ME
author:
  - first_name: "Jake"
    last_name: "Wittman"
    url: https://wittja01.github.io/website/
date: 2022-08-26
#image: preview.jpg  # <---- UPDATE ME 
license: CC BY
repository_url: https://github.com/wittja01/website
params:
  slug: messing-around-with-xgboost
  date: 2022-08-26
  repo: wittja01/website
  site: https://wittja01.github.io/website
draft: true
---

<!----
Use 
refinery::use_article_template(
    template = "_templates/standard_template.Rmd",
    slug = "how-cold-is-too-cold", 
    date = "2022-01-11",
    renv_new = TRUE
)
to generate new post

checklist:
  - check the "update me" messages in YAML above
  - initialise the _renv folder with refinery::renv_new("name of post folder")
  - populate the lockfile with refinery::renv_snapshot("name of post folder")
  - update the _renv folder from snapshot with refinery::restore("name of post folder")

---->


<!--------------- setup post ----------------->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```


<!--------------- post ----------------->

I've been following Danielle Navarro and Thomas Lin Pederson on Twitter for some time. These two introduced me to generative art, and I kind of love the art they make. I love the idea of taking data and making artwork from it, through transformations or choices in how to display or map the data to the visualization. When I found out Danielle had made her workshop available as a [webpage](https://art-from-code.netlify.app/day-1/session-1/), I was real excited to work through it. So, here I am! I'll be reproducing some of her code here just for my own edification, and also working through some of the exercises she provides. This post will just be working through her very first section on technique and color. I'll tackle the others later.

First, let's take just a few minutes and try to make some art out of mpg like directed.

```{r}
library(ggplot2)
library(tibble)
library(dplyr)
library(magrittr)

mpg %>% 
   ggplot(aes(x = hwy, y = cty)) +
   geom_point(aes(color = displ, size = displ), show.legend = FALSE) + 
   #geom_point(color = 'white', shape = 4) +
   coord_polar() +
   theme_void() +
   scale_color_distiller(type = 'div')
```

Okay! It's a thing. Not my favorite thing, but it's a thing.

Now on to using the polar art function she provided.

```{r}
polar_art <- function(seed, n, palette) {
  
  # set the state of the random number generator
  set.seed(seed)
  
  # data frame containing random values for 
  # aesthetics we might want to use in the art
  dat <- tibble(
    x0 = runif(n),
    y0 = runif(n),
    x1 = x0 + runif(n, min = -.2, max = .2),
    y1 = y0 + runif(n, min = -.2, max = .2),
    shade = runif(n), 
    size = runif(n)
  )
  
  # plot segments in various colours, using 
  # polar coordinates and a gradient palette
  dat %>%  
    ggplot(aes(
      x = x0,
      y = y0,
      xend = x1,
      yend = y1,
      colour = shade,
      size = size
    )) +
    geom_segment(show.legend = FALSE) +
    coord_polar() +
    scale_y_continuous(expand = c(0, 0)) +
    scale_x_continuous(expand = c(0, 0)) + 
    scale_colour_gradientn(colours = palette) + 
    scale_size(range = c(0, 10)) + 
    theme_void()
}

polar_art(seed = 314, n = 50, c('green', 'purple', 'pink'))
polar_art(seed = 314, n = 100, c('green', 'purple', 'blue', 'yellow', 'orange'))
polar_art(seed = 314, n = 80, c('red', 'black', 'blue'))
polar_art(seed = 314, n = 500, c('green', 'black', 'grey'))
```

Now I'm supposed to try editing the polar art to create my own system.

```{r}
polar_art2 <- function(seed, n, palette) {
  
  # set the state of the random number generator
  set.seed(seed)
  
  # data frame containing random values for 
  # aesthetics we might want to use in the art
  dat <- tibble(
    x0 = runif(n),
    y0 = runif(n),
    x1 = x0 + rnorm(n, sd = 10),
    y1 = y0 + rnorm(n, sd = 10),
    shade = runif(n), 
    size = runif(n)
  )
  
  # plot segments in various colours, using 
  # polar coordinates and a gradient palette
  dat %>%  
    ggplot(aes(
      x = x0,
      y = y0,
      xend = x1,
      yend = y1,
      colour = shade,
      size = size
    )) +
    geom_curve(show.legend = FALSE) +
    scale_y_continuous(expand = c(0, 0)) +
    scale_x_continuous(expand = c(0, 0)) + 
    scale_colour_gradientn(colours = palette) + 
    scale_size(range = c(0, 5)) + 
    theme_void()
}
```

This new function drops the coord_polar, so I probably should rename it from polar_art, but I'm feeling a bit lazy. I might call this one "Windmill Art". I kind of like how using a normal distribution for the ends causes some "outliers" to appear that are much longer than the others.

```{r}
library(patchwork)
(polar_art2(seed = 20, n = 50, c('red', 'yellow', 'blue')) +
polar_art2(seed = 98765431, n = 100, c('red', 'yellow', 'blue'))) /
(polar_art2(seed = 421, n = 200, c('green', 'yellow', 'blue')) +
polar_art2(seed = 3256, n = 20, c("#001021","#034748","#1481ba","#11b5e4","#0caadc")))
```

## Colors

The [coolors.co](coolors.co) website that Danielle introduces us to seems really awesome for generating custom color palettes.

```{r}
library(scales)
library(ggthemes)
show_col(c("#001021","#034748","#1481ba","#11b5e4","#0caadc"))
```

The `scale_color_gradientn()` function will generate a sequence of colors interpolated between your chosen palette, or it can be done manually using `colorRampPalette()`. Note that `colorRampPalette()` actually returns a function that takes an integer to specify how many colors to return.

```{r}
colorRampPalette(c("#001021","#034748","#1481ba","#11b5e4","#0caadc"))(100)
show_col(colorRampPalette(c("#001021","#034748","#1481ba","#11b5e4","#0caadc"))(100))
```

To visualize the colors as a smooth palette:

```{r}
image(
  x = matrix(1:100, ncol = 1), 
  col = colorRampPalette(c("#001021","#034748","#1481ba","#11b5e4","#0caadc"))(50),
  useRaster = TRUE,
  axes = FALSE
)
```

Can get other palettes from `canva_palettes` from ggthemes
```{r}
show_col(canva_palettes[[23]])
```

Could write a function that randomly samples a palette from these palettes

```{r}
sample_canva <- function(seed = NULL) {
  if(!is.null(seed)) set.seed(seed)
  sample(ggthemes::canva_palettes, 1)[[1]]
}
```

```{r}
polar_art(seed = 2, n = 100, palette = sample_canva(seed = 120)) +
polar_art(seed = 2, n = 100, palette = sample_canva(seed = 82)) +
polar_art(seed = 2, n = 100, palette = sample_canva(seed = 44))
```

Or if I want to use the same palette but vary the art

```{r}
polar_art(seed = 26123, n = 100, palette = sample_canva(seed = 82)) +
polar_art(seed = 243, n = 100, palette = sample_canva(seed = 82)) +
polar_art(seed = 12342, n = 100, palette = sample_canva(seed = 82))
```

Now, time to try creating my own function to sample random colors to build a completely random palette.

```{r}
sample_named_colours <- function(n) {
   sample(colours(distinct = TRUE), n)
}
```

```{r}
polar_art(seed = 29, n = 50, palette = sample_named_colours(8))
```

```{r}
# This function should randomly sample from the 600 distinct colors available
# from canva
random_sample_canva <- function(n) {
   sample(unlist(canva_palettes), n)
}
```

```{r}
polar_art(seed = 29, n = 500, palette = random_sample_canva(120))
```

The polar art function is nice, but it doesn't give a lot of control. Danielle provides some code to separate out the data generation from the plotting, and also sets up the plot function so we can alter the geom we are plotting.

```{r}
sample_data <- function(seed = NULL, n = 100){
  if(!is.null(seed)) set.seed(seed)
  dat <- tibble(
    x0 = runif(n),
    y0 = runif(n),
    x1 = x0 + runif(n, min = -.2, max = .2),
    y1 = y0 + runif(n, min = -.2, max = .2),
    shade = runif(n), 
    size = runif(n),
    shape = factor(sample(0:22, size = n, replace = TRUE))
  )
}
polar_styled_plot <- function(data = NULL, palette) {
  ggplot(
    data = data,
    mapping = aes(
      x = x0,
      y = y0,
      xend = x1,
      yend = y1,
      colour = shade,
      size = size
    )) + 
    coord_polar(clip = "off") +
    scale_y_continuous(
      expand = c(0, 0),
      limits = c(0, 1), 
      oob = scales::oob_keep
    ) +
    scale_x_continuous(
      expand = c(0, 0), 
      limits = c(0, 1), 
      oob = scales::oob_keep
    ) + 
    scale_colour_gradientn(colours = palette) + 
    scale_size(range = c(0, 10)) + 
    theme_void() + 
    guides(
      colour = guide_none(),
      size = guide_none(),
      fill = guide_none(),
      shape = guide_none()
    )
}
```


```{r}
dat <- sample_data(n = 100, seed = 1231) 
pal <- sample_canva(seed = 63)

polar_styled_plot(data = dat, palette = pal) + geom_segment() +
polar_styled_plot(data = dat, palette = pal) + geom_path() +
polar_styled_plot(data = dat, palette = pal) + geom_point()
```

This style of function writing also allows us to construct pieces that combine multiple geoms and/or data

```{r}
library(dplyr)

dat1 <- sample_data(n = 2000, seed = 1223) 
dat2 <- sample_data(n = 100, seed = 4536)  %>%   
  mutate(y0 = .3 + y0 * .6, y1 = .3)

polar_styled_plot(palette = sample_canva(seed = 7)) + 
  geom_segment(
    data = dat1  %>%  mutate(size = size * 3)
  ) + 
  geom_segment(
    data = dat2 %>% mutate(size = size / 5), 
    lineend = "round", 
    colour = "white"
  ) +
  geom_segment(
    data = dat2 %>% mutate(size = size / 40), 
    lineend = "round", 
    colour = "#222222"
  ) +
  geom_point(
    data = dat2 %>% mutate(size = size * 2),
    colour = "#222222"
  )
```

Alright, now time to try this on my own. For this next exercise I'm supposed to use the sample_data(), polar_styled_plot() and adding different geoms to make my own pieces. 

```{r}
dat1 <- sample_data(n = 50, seed = 54267)
dat2 <- sample_data(n = 20, seed = 123)
dat3 <- sample_data(n = 100, seed = 54573)

# I think I'll use this one as the preview image for the blog
polar_styled_plot(palette = sample_canva(seed = 10928)) +
   geom_point(data = dat3, aes(size = size)) +
   geom_line(data = dat1, aes(size = size / 20))
ggsave('posts/2022-08-19_generative_art_1/preview.jpg')

polar_styled_plot(palette = sample_canva(seed = 4346)) +
   geom_point(data = dat2, size = 6) +
   geom_line(data = dat2, size = 0.5) +
   geom_point(data = dat2%>% mutate(y1 = y1 - 0.8, x0 = x1 - 0.2), 
              size = 6) +
   geom_line(data = dat2 %>% mutate(y1 = y1 - 0.8, x0 = x1 - 0.2),
             size = 0.5) +
   geom_point(data = dat2%>% mutate(y1 = y1 + 0.4, x0 = x0 - 0.2), 
              size = 6) +
   geom_line(data = dat2 %>% mutate(y1 = y1 + 0.4, x0 = x0 - 0.2),
             size = 0.5)
```

I think I like the first of these two better. It's kind of got an aggressive toddler connecting the dots vibe that I like. The other one feels a bit kitschy to me. This is lots of fun! I have almost no other artistic talents, so this is a cool way to express myself and try to find aesthestics that I enjoy. I look forward to working through more of these tutorials as time allows.
